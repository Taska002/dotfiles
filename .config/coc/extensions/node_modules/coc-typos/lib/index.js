"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module2) {
    function debounce2(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (wait == null)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce2.debounce = debounce2;
    module2.exports = debounce2;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc5 = require("coc.nvim");

// src/ignored.ts
var import_coc2 = require("coc.nvim");
var import_fs2 = __toESM(require("fs"));

// src/util.ts
var import_child_process = require("child_process");
var import_coc = require("coc.nvim");
var import_debounce = __toESM(require_debounce());
var import_fs = __toESM(require("fs"));
var import_readline = __toESM(require("readline"));
function spawnCommand(cmd, args, lines, token, onLine) {
  const cp = (0, import_child_process.spawn)(cmd, args, { cwd: process.cwd() });
  return new Promise((resolve, reject) => {
    let disposable = token.onCancellationRequested(() => {
      disposable.dispose();
      reject(new Error("Cancelled"));
      cp.kill();
    });
    cp.on("error", (err) => {
      reject(err);
    });
    const rl = import_readline.default.createInterface({
      input: cp.stdout,
      terminal: false
    });
    rl.on("line", (line) => {
      onLine(line);
    });
    rl.on("close", () => {
      resolve();
    });
    for (let line of lines) {
      cp.stdin.write(line + "\n");
    }
    cp.stdin.end();
    cp.stderr.on("data", (data) => {
      import_coc.window.showErrorMessage(`"${cmd} ${args.join(" ")}" error: ${data.toString()}`);
    });
  });
}
function parseLine(line) {
  if (line.length == 0)
    return void 0;
  try {
    let obj = JSON.parse(line);
    return {
      type: obj.type,
      word: obj.typo,
      lnum: obj.line_num - 1,
      colStart: obj.byte_offset,
      colEnd: obj.byte_offset + Buffer.byteLength(obj.typo),
      corrections: obj.corrections
    };
  } catch (e) {
    console.log(`Parse error: ${e.message}`);
    return void 0;
  }
}
function getTyposBuffer(cmd, args, lines, token) {
  let res = [];
  return new Promise((resolve, reject) => {
    spawnCommand(cmd, [...args, "--format=json", "-"], lines, token, (line) => {
      let item = parseLine(line);
      if (item)
        res.push(item);
    }).then(() => {
      res.sort((a, b) => {
        if (a.lnum != b.lnum)
          return a.lnum - b.lnum;
        return a.colStart - b.colStart;
      });
      resolve(res);
    }, reject);
  });
}
function padLeft(s, n, pad = " ") {
  return pad.repeat(Math.max(0, n - s.length)) + s;
}
function now() {
  const now2 = new Date();
  return padLeft(now2.getUTCHours() + "", 2, "0") + ":" + padLeft(now2.getMinutes() + "", 2, "0") + ":" + padLeft(now2.getUTCSeconds() + "", 2, "0") + "." + now2.getMilliseconds();
}
function watchFile(filepath, onChange) {
  let callback = (0, import_debounce.default)(onChange, 100);
  try {
    let watcher = import_fs.default.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    return import_coc.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_coc.Disposable.create(() => {
      callback.clear();
    });
  }
}

// src/ignored.ts
var Ignored = class {
  constructor(output) {
    this.output = output;
    this.ignoredWords = /* @__PURE__ */ new Map();
    this.files = [];
    this.disposables = [];
    this._onDidChange = new import_coc2.Emitter();
    this.onDidChange = this._onDidChange.event;
    import_coc2.workspace.nvim.getOption("spellfile").then((spellfile) => {
      if (spellfile) {
        this.files = spellfile.split(",").map((s) => import_coc2.workspace.expand(s));
        for (let file of this.files) {
          this.watchFile(file);
        }
        this.loadFiles().then(() => {
          this._onDidChange.fire();
        });
      }
    });
  }
  async loadFiles() {
    await Promise.all(this.files.map((file) => this.loadFile(file)));
  }
  watchFile(filepath) {
    this.output.appendLine(`[Info - ${now()}] Watching spellfile ${filepath}`);
    this.disposables.push(watchFile(filepath, () => {
      this.loadFile(filepath, true);
    }));
  }
  loadFile(filepath, fireEvent = false) {
    return new Promise((resolve) => {
      if (!import_fs2.default.existsSync(filepath))
        return resolve();
      import_fs2.default.readFile(filepath, "utf8", (err, data) => {
        if (err)
          return;
        let words = data.trim().split(/\r?\n/).filter((s) => !s.startsWith("#"));
        this.ignoredWords.set(filepath, words);
        this.output.appendLine(`[Info - ${now()}] Loaded ${words.length} words from spellfile ${filepath}`);
        if (fireEvent)
          this._onDidChange.fire();
        resolve();
      });
    });
  }
  isIgnored(word) {
    for (let words of this.ignoredWords.values()) {
      if (words.includes(word))
        return true;
    }
    return false;
  }
  dispose() {
    (0, import_coc2.disposeAll)(this.disposables);
  }
};

// src/item.ts
var import_coc3 = require("coc.nvim");
var import_fs3 = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_util2 = require("util");
var NAMESPACE = "typos";
var TyposBuffer = class {
  constructor(doc, config, output, checkIgnored) {
    this.doc = doc;
    this.config = config;
    this.output = output;
    this.checkIgnored = checkIgnored;
    this.tokenSource = new import_coc3.CancellationTokenSource();
    this.typos = [];
    this.mutex = new import_coc3.Mutex();
    void this.check();
  }
  get buffer() {
    return this.doc.buffer;
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
    }
  }
  async addToKnownWordAtCursor() {
    let [line, col] = await import_coc3.workspace.nvim.eval('[line(".")-1,col(".")-1]');
    let item = this.findTypo(line, col);
    if (!item)
      return void import_coc3.window.showWarningMessage(`Typo not found at cursor position`);
    let spellfile = await this.doc.buffer.getOption("spellfile");
    if (spellfile)
      spellfile = import_coc3.workspace.expand(spellfile);
    if (!spellfile) {
      void import_coc3.window.showWarningMessage(`spellfile option not exists`);
      return;
    }
    if (!import_fs3.default.existsSync(spellfile)) {
      let res = await import_coc3.window.showPrompt(`Spellfile ${spellfile} not exists, create?`);
      if (!res)
        return;
      let folder = import_path.default.dirname(spellfile);
      import_fs3.default.mkdirSync(folder, { recursive: true });
      import_fs3.default.writeFileSync(spellfile, "", "utf8");
    }
    import_fs3.default.appendFileSync(spellfile, `${item.word}
`);
  }
  onChange(e) {
    if (this.config.disabledFiletypes.includes(this.doc.filetype))
      return;
    if (e.contentChanges.length == 0) {
      this.addHighlights();
      return;
    }
    void this.check(e);
  }
  addHighlights() {
    let { nvim } = import_coc3.workspace;
    let hlGroup = this.config.highlightGroup;
    let items = [];
    for (let i = 0; i < this.typos.length; i++) {
      for (let o of this.typos[i]) {
        if (this.checkIgnored(o.word))
          continue;
        items.push({
          hlGroup,
          lnum: i,
          colEnd: o.colEnd,
          colStart: o.colStart,
          start_incl: false,
          end_incl: false
        });
      }
    }
    nvim.pauseNotification();
    this.buffer.setVar("coc_typos_count", items.length, true);
    this.buffer.updateHighlights(NAMESPACE, items);
    nvim.resumeNotification(true, true);
  }
  findTypo(lnum, col) {
    let arr = this.typos[lnum];
    return arr.find((o) => o.colStart <= col && o.colEnd >= col);
  }
  async check(e) {
    let { doc } = this;
    if (!doc.attached)
      return;
    if (this.config.disabledFiletypes.includes(doc.filetype)) {
      this.warn(`${doc.uri} ignored by typos.disabledFiletypes`, doc.filetype);
      return;
    }
    let textDocument = doc.textDocument;
    await this.mutex.use(async () => {
      if (this.tokenSource.token.isCancellationRequested)
        return;
      let cmd = this.config.command;
      try {
        let token = this.tokenSource.token;
        if (!e) {
          let len = textDocument.lineCount;
          let typoList = await getTyposBuffer(cmd, this.config.arguments, textDocument.lines, token);
          this.info(`${typoList.length} typos found for ${doc.uri}.`);
          this.typos = [];
          for (let i = 0; i < len; i++) {
            let arr = typoList.filter((o) => o.lnum === i);
            this.typos.push(arr);
          }
        } else {
          let { range, text } = e.contentChanges[0];
          let { start, end } = range;
          let sl = start.line;
          let el = end.line;
          let del = el - sl;
          let newLines = textDocument.lines.slice(sl, sl + text.split(/\n/).length);
          let typoList = await getTyposBuffer(cmd, this.config.arguments, newLines, token);
          let arr = [];
          for (let i = 0; i < newLines.length; i++) {
            let items = typoList.filter((o) => o.lnum === i);
            arr.push(items);
          }
          this.typos.splice(sl, del + 1, ...arr);
        }
        this.addHighlights();
      } catch (e2) {
        if (e2 instanceof Error && e2.message.includes("Cancelled"))
          return;
        this.error(`Error on command: ${cmd}`, e2);
      }
    });
  }
  info(message, data) {
    this.logLevel("Info", message, data);
  }
  warn(message, data) {
    this.logLevel("Warn", message, data);
  }
  error(message, data) {
    this.logLevel("Error", message, data);
  }
  logLevel(level, message, data) {
    this.output.appendLine(`[${level} - ${now()}] ${message}`);
    if (data)
      this.output.appendLine(this.data2String(data));
  }
  data2String(data) {
    if (data instanceof Error) {
      if (typeof data.stack === "string") {
        return data.stack;
      }
      return data.message;
    }
    if (typeof data === "string" || typeof data === "boolean") {
      return data.toString();
    }
    return (0, import_util2.inspect)(data, { maxArrayLength: 5 });
  }
  dispose() {
    this.cancel();
  }
};

// src/list.ts
var import_child_process2 = require("child_process");
var import_coc4 = require("coc.nvim");
var import_events = require("events");
var import_path2 = __toESM(require("path"));
var import_readline2 = __toESM(require("readline"));
var Task = class extends import_events.EventEmitter {
  start(cmd, cwd, args, checkIgnored) {
    let process2 = this.process = (0, import_child_process2.spawn)(cmd, [".", "--format", "brief", "--color", "always"].concat(args), { cwd });
    process2.on("error", (e) => {
      this.emit("error", e.message);
    });
    const rl = import_readline2.default.createInterface(process2.stdout);
    process2.stderr.on("data", (chunk) => {
      console.error(chunk.toString("utf8"));
    });
    rl.on("line", (line) => {
      if (line.length == 0)
        return;
      let items = (0, import_coc4.ansiparse)(line);
      let text = items.reduce((p, c) => {
        return p + c.text;
      }, "");
      let parts = text.split(":");
      let ms = text.match(/`(.*?)`/);
      let word = ms ? ms[1] : "";
      if (checkIgnored(word))
        return;
      let lnum = parseInt(parts[1], 10);
      let byteIndex = parseInt(parts[2], 10);
      let fullpath = import_path2.default.join(cwd, parts[0]);
      let location = import_coc4.Location.create(import_coc4.Uri.file(fullpath).toString(), import_coc4.Range.create(lnum - 1, byteIndex, lnum - 1, byteIndex + word.length));
      this.emit("data", {
        label: line,
        sortText: parts[0],
        location
      });
    });
    rl.on("close", () => {
      this.emit("end");
    });
  }
  dispose() {
    let { process: process2 } = this;
    if (process2 && !process2.killed) {
      process2.kill();
    }
  }
};
var TyposList = class extends import_coc4.BasicList {
  constructor(nvim, ignored) {
    super(nvim);
    this.ignored = ignored;
    this.name = "typos";
    this.defaultAction = "open";
    this.description = "Check typos for project files ";
    this.options = [{
      name: "-W, -workspace",
      description: "Use current workspace folder instead of cwd."
    }];
    this.addLocationActions();
  }
  async loadItems(context) {
    let config = import_coc4.workspace.getConfiguration("typos");
    let cmd = config.get("command", "typos");
    let args = config.get("listTyposArguments", []);
    let options = this.parseArguments(context.args);
    let cwd = options.workspace ? import_coc4.workspace.root : import_coc4.workspace.cwd;
    let task = new Task();
    task.start(cmd, cwd, args, (word) => {
      return this.ignored.isIgnored(word);
    });
    return task;
  }
};

// src/index.ts
async function getHighlights() {
  let buf = await import_coc5.workspace.nvim.buffer;
  return await buf.getHighlights(NAMESPACE);
}
function jumpTo(item) {
  import_coc5.workspace.nvim.call("cursor", [item.lnum + 1, item.colStart + 1], true);
}
function characterIndex(content, byteIndex) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex).toString("utf8").length;
}
async function activate(context) {
  let { subscriptions } = context;
  let { nvim } = import_coc5.workspace;
  let channel = import_coc5.window.createOutputChannel("typos");
  let ignored = new Ignored(channel);
  subscriptions.push(channel);
  subscriptions.push(ignored);
  let bufferSync = import_coc5.workspace.registerBufferSync((doc) => {
    let config = import_coc5.workspace.getConfiguration("typos", doc.uri);
    return new TyposBuffer(doc, {
      command: config.get("command", "typos"),
      arguments: config.get("arguments", []),
      disabledFiletypes: config.get("disabledFiletypes", []),
      highlightGroup: config.get("highlightGroup", "SpellBad")
    }, channel, (word) => {
      return ignored.isIgnored(word);
    });
  });
  const refreshAll = () => {
    for (let item of bufferSync.items) {
      item.addHighlights();
    }
  };
  subscriptions.push(bufferSync);
  subscriptions.push(ignored.onDidChange(() => {
    refreshAll();
  }));
  subscriptions.push(import_coc5.workspace.registerKeymap(["n"], "typos-next", async () => {
    let hls = await getHighlights();
    if (!hls.length)
      return import_coc5.window.showWarningMessage("No typos exists");
    let [lnum, col, wrapscan] = await nvim.eval(`[line('.')-1,col('.')-1,&wrapscan]`);
    for (let i = 0; i < hls.length; i++) {
      let item = hls[i];
      if (item.lnum > lnum || item.lnum == lnum && item.colStart > col) {
        jumpTo(item);
        return;
      }
    }
    if (wrapscan)
      jumpTo(hls[0]);
  }, { sync: false }), import_coc5.workspace.registerKeymap(["n"], "typos-prev", async () => {
    let hls = await getHighlights();
    if (!hls.length)
      return import_coc5.window.showWarningMessage("No typos exists");
    let [lnum, col, wrapscan] = await nvim.eval(`[line('.')-1,col('.')-1,&wrapscan]`);
    for (let i = hls.length - 1; i >= 0; i--) {
      let item = hls[i];
      if (item.lnum < lnum || item.lnum == lnum && item.colEnd < col) {
        jumpTo(item);
        return;
      }
    }
    if (wrapscan)
      jumpTo(hls[hls.length - 1]);
  }, { sync: false }), import_coc5.workspace.registerKeymap(["n"], "typos-fix", async () => {
    let bufnr = await nvim.call("bufnr", ["%"]);
    let item = bufferSync.getItem(bufnr);
    if (!item)
      return import_coc5.window.showWarningMessage("Document not attached");
    let [lnum, col] = await nvim.eval(`[line('.')-1,col('.')-1,&wrapscan]`);
    let typo = item.findTypo(lnum, col);
    if (!typo)
      return import_coc5.window.showWarningMessage("No bad spelled word found at cursor position");
    let doc = import_coc5.workspace.getDocument(bufnr);
    let n = await import_coc5.window.showMenuPicker(typo.corrections, { title: "Pick word" });
    if (n < 0)
      return;
    let content = doc.getline(lnum);
    let text = typo.corrections[n];
    let range = import_coc5.Range.create(lnum, characterIndex(content, typo.colStart), lnum, characterIndex(content, typo.colStart + typo.word.length));
    await doc.applyEdits([import_coc5.TextEdit.replace(range, text)]);
    await nvim.command(`silent! call repeat#set("\\<Plug>(coc-typos-fix)", -1)`);
  }, { sync: false }));
  subscriptions.push(import_coc5.listManager.registerList(new TyposList(nvim, ignored)));
  subscriptions.push(import_coc5.commands.registerCommand("typos.reloadSpellfile", () => {
    ignored.loadFiles();
    refreshAll();
  }), import_coc5.commands.registerCommand("typos.addToSpellfile", async () => {
    let bufnr = await nvim.call("bufnr", ["%"]);
    let item = bufferSync.getItem(bufnr);
    if (!item)
      return import_coc5.window.showWarningMessage(`Buffer not attached`);
    await item.addToKnownWordAtCursor();
    refreshAll();
  }));
}
"use strict";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
//# sourceMappingURL=index.js.map
